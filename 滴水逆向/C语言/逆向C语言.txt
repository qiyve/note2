什么是裸函数？

关键字  __declspec(naked)

void  __declspec(nakecd) Function()
{ 
   //c中汇编格式   __asm {}
     __asm {
	 ret 
	} 
}

编译器不会管   没人管
优点：可以按照自己的想法让函数编译
裸函数必须写 ret 不然无法执行

常见的几种调用约定

调用约定      |     参数压栈顺序        |  平衡堆栈  
__cdecl        |     从右至左入栈        |  调用者清理栈	
__stdcall      |   从右至左入栈          |  自身清理堆栈
__fastcall     |  ECX/EDX传送前两个 |   自身清理堆栈
                   | 剩下:从右至左入栈     |	

内屏栈：在call函数内部平衡
外屏栈：在call函数外边平衡


将一个float型转化为内存存储格式的步骤

1.先将这个是数的绝对值化为二进制格式
2.将这个二进制格式实数的小数点左移或右移n位，直到小数点移动到第一个有效数字的右边
3.从小数点右边第一位开始数出二十三位数字放入第22到第0位
4.如果实数是正的，则在第31位放入“0”，否则放入“1”
5.如果n是左移得到的，说明指数是正的，第30位放入“1”，如果n是右移得到的或n=0，则第30位放入“0”
6.如果n是左移得到的，则将n减去1后化为二进制在左边加“0”补足七位，放入第29到23位。
  如果n是右移得到的或n=0，则将n化为二进制后在左边加“0”补足七位，再各位求反，再放入第29到
  第23位


例如：0.25      小数部分从上向下看

整数部分：0

0.25 * 2 =0.5    0
0.5 * 2  = 1.0    1

0.25转换成二进制：0.01

0.01 右移2位 1.0   指数为-2    

如果左移指数位第一位为 1 ；右移为0
指数部分计算：指数 - 1
-2-1 =-3       FD=-3      1111 1101

0011 1110 1000 0000 0000 0000 0000 0000
 3E800000               


例 12.5 转换成16进制     整数部分从下向上看
整数部分12转成二进制

12 / 2 = 6		0
6 / 2    =3		0
3 / 2    =1		1
1 / 2    =0		1

小数部分  0.5
 
0.5 * 2 = 1.0     	1

1100.1 = 1.1001 * 2的三次方   小数点左移3位指数为3        3+1     0010

0100 0001 0100 1000 00000 0000 0000 0000 0000
41480000


如何判断函数参数

1、不考虑ebp、esp
2、只找给别人赋值的寄存器 eax，ecx，edx，ebx，esi，edi
3、找到以后追查其来源，如果，该寄存器中的值不是在函数内存赋值的，那
 一定是传进来的参数

公式一：寄存器 + ret 4 = 参数个数

公式二：寄存器 + [ebp+8] + [ ebp+ 0x] = 参数个数


if(){}    else{}  语句反汇编判断

特点分析：

1、如果不跳转，那么会执行到jmp处，jmp直接跳转到END除
2、如果跳转，则直接跳过jmp END处的代码，执行后面的代码

总结：跳转 执行一部分代码，不跳转执行另一部分代码
第一个jcc指令跳转的地址前面有一个jmp，可以判断是 if.....else....语句


if...else if.....else if....else 多分支语句的反汇编判断

1、当每个条件跳转指令要跳转的地址前面都有jmp 指令
2、这些jmp指令跳转的地址都是一样的
3、如果某个分支没有条件判断，则为else部分


表达式：

特点一：表达式无论多么复杂，都只有一个结果
特点二：只有表达式，可以编译通过，但并不生成代码，需要与分支或者其他流程控制语句
             一起组合的时候才有意义
特点三：表达式中存在不同宽度的变量时，结果将转换为宽度最大的那个
特点四：当表达式中同时存在有符号和无符号的时候，表达式的结构将转化为无符号数


1、本机尺寸：
     如果本机是32位的，那么对32位的数据支持最好，如果是64位的，那么对64位的支持

2、编译器遵守了这个规则:
     char类型或者short类型的参数不但没有节省空间，反而浪费了多余的操作.
  
总结：整数类型的参数，一律使用int类型

参数传递的本质：将上层函数的变量，或者表达式的值“赋值一份”，传递给下层函数


局部变量内存分配：

1、小于32位的局部变量，空间在分配时，按32位分配
2、使用时按实际宽度使用
3、不要定义char/short类型的局部变量
4、参数与局部变量没有本质区别，都是局部变量都在栈中
5、完全可以把参数当初始局部变量使用

数组的本质：

1、一组相同类型的变量，为了方便读写，采用另一种表示形式
2、数组在声明的时候，必须用常量来指明长度，不能使用变量


练习：
1、返回值超过32位时，存在哪里？用long long(__int64)类型做实验？

返回值存在堆栈中，编译器会先利用EAX辅助 存储在两个32位的局部变量，利用两块四字节的内存存储
	long long x = 0x1234567890;
00061785  mov         eax,12h  
0006178A  mov         dword ptr [ebp-0Ch],34567890h  
00061791  mov         dword ptr [ebp-8],eax
                 return x;  返回值
00351015  mov         eax,dword ptr [x]  
00351018  mov         edx,dword ptr [ebp-4] 

返回值通过eax跟edx传出，edx存储的是高位


2、char arr[3] = {1,2,3};与 char arr[4] = {1,2,3,4};
哪个更节省空间，从反汇编的角度来说明你的观点

分配的空间都一样



shl是逻辑左移指令，它的功能为：

1. 将寄存器或内存单元中的数据向左移位
2.将最后溢出的一位写入CF中
3.最低位用0补充

指令：

MOV  AL, 0100 1000  

shl   al,   1    将al中的数据左移一位

执行后（al）=1001 0000    CF = 0



数组的反汇编特点： 连续的空间且 等宽


为什么要有数据对齐？

本质：效率还是空间，二选一的结果

对齐参数：n为字节对齐数，其取值为1、2、4、8，默认是8

对齐原则：

原则一： 数据成员对齐规则：结构的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的起始位置要从
             该成员大小的整数倍开始（比如int在32位机位4字节，则要从4的整数倍地址开始存储

原则二：结构体的总大小，也就是sizeof的结构，必须是其内存最大成员的整数倍，不足的要补齐
             (struct a里存有struct b，b里有char，int，double等元素，那b应该从8的整数倍开始存储.)

原则三：如果一个结构里有某些结构成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储

原则四：对齐参数如果比结构体成员的sizeof值小，该成员的偏移量应该以此为准
             也就是说，结构体成员的偏移量应该取二者的最小值
 

swich语句：

1、分支少于4的时候，用swich没有意义，因为编译器会生成类似于if....else之类的汇编
2、case后面的常量可以是无序的，并不影响大表的生成












                 