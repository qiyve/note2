吃字母游戏
   TCHAR 字符串操作函数

    _tcslen（str）// 获取字符串长度
    _tcsrchr（str, L'\\')  //反向搜索获得最后一个TCHAR的位置
    _stprintf(TCHAR *buffer,const TCHAR *format [,argument] ... )    //获得一个格式化字符串
    _tcsduo	//给一个指针分配源字符串大小的内存并从源字符串copy值
    _tcstok 	//按标记将字符串拆分
    tcscpy		//拷贝字符串

1.功能

     在资源文本框中输入一串字母
     点击按钮，将把字符串中的字母读入自己的文本框中，然后会叫缓冲区置0；
     4个消费者线程会从缓存区中将字母读入自己的文本框中，然后会将缓冲区置0；
     生产者线程在缓冲区为0时再次将后面的字句写入缓冲区；

2.思路
   （1）线程
      需要生产者线程；用来读取资源文本框中的字符串，并按顺序将字符串中的每个字符写入缓存区；

    线程同步：
        消费者线程需要在生产者线程将字符写入缓冲区后才能从缓冲区中读取字符；

    线程互斥：
        同一时刻只能有一个线程来操作缓冲区；

   生产者：
       从资源文本框中读取字符串；
       循环将每个字符写入缓冲区文本框
       缓冲区文本框有2个，需要循环判断，只要其中一个为0则将字符写入；写入后退出循环，开始处理下一个字符；
       当字符串中的所有字符处理完后生产者线程结束；
       可以获取字符串的长度来判断生产者线程结束标记；

   消费者
     主要做三件事：
       从缓冲区文本框中读取字符；
       见缓冲区中的字符写入自己的文本框；
       将缓冲区文本框置0告诉生产者这个缓冲区中的字符被读完了；
  线程结束   
       消费者线程需要在生产者将所有字符处理完，并且缓冲区中的字符全部被读完后结束；
       如果线程不结束程序会卡死
       结束线程有两种方式：超过一定的等待时间，用全局变量做标记，生产者完成后修改标记；
       这里用第一种方式来实现线程结束

---------------------------------------------------------------------------------------------------------------------------------

线程互斥：

       当多个线程访问同一个全局变量，或者同一个资源（比如打印机）的时候，需要药进行线程的互斥操作
   来抱枕访问的安全性。
        临界区、互斥体、事件和信号量都可以实现线程互斥.但如果仅仅需要实现互斥功能，推荐前两种:										
																				
	初始化			进入互斥区域		离开互斥区域		   销毁
										
临界区	Initialize-CriticalSection	Enter-CriticalSection	Leave-CriticalSection	DeleteCriticalSection
										
互斥体	CreateMutex		WaitForSingleObject	ReleaseMutex		CloseHandle
										
										
两者的区别：										
										
1、临界区只能用于进程内的线程互斥，性能较好.										
										
2、互斥体属于内核对象，可以用于进程间的线程互斥，性能较差.										
										
3、线程在没有正常退出互斥区而意外终结时，互斥体可以复位，但临界区不行.										


进程同步：								
								
    当有多个线程同时执行时，可能需要线程按照一定的顺序执行，比如：线程A负责将要处理的数据读取到内存中，而线程B								
负责分析这些数据，此时，应该是线程A执行完毕再执行线程B才有意义，这个时候就需要进行线程的同步控制。								
								
可以用于线程同步控制的对象：事件和信号量								
								
								
事件：																
创建		使事件进入触发状态		使事件进入未触发状态	销毁								
CreateEvent	SetEvent			ResetEvent		CloseHandle
																
信号量：														
创建			递减计数		    递增计数		销毁								
CreateSemaphore	    WaitForSingleObject	ReleaseSemaphore	          CloseHandle								
								
两者的区别：																
1、都是内核对象，使用完毕后应该关闭句柄.								
								
2、信号量可以用于相当复杂的线程同步控制.								
								









































   