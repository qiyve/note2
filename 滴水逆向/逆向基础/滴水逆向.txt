找返值关注  EAX
找参数    EBP+8 后面
局部遍历  EBP-4 后面


十进制 ：由是十个符号组成   1 2 3 4 5 6 7 8 9 逢十进一
十六进制：十六个符号组成  0 1 2 3 4 5 6 7 8 9 A B C D E F 逢十六进一
二进制： 逢二进一
八进制：八个字符   逢八进一

可以重新定制符号来起到加密功能

二进制记住:  (4) 0100   |（8)1000   | (16) 0010 0000  |  (32) 0010 0000 | (64) 0100 0000  | (128) 1000 0000


1、2+3=1 是否成立？
成立，元素是可以自己定义 如十进制的定义如下： 0 2 3 1 8 7 6 9 4 5

2、二进制与十六进制的对应关系

二进制        十六进制
0000             0
0001             1
0010             2
0011             3
0100             4
0101             5
0110             6
0111             7
1000             8
1001             9
1010             A
1011             B
1100             C
1101             D
1110             E
1111             F

3、编制7进制加法表，乘法表 并计算下面结果： 23456+54356=？ 5621-654=？ 234*65=？

1+1 = 2，
1+2 = 3，  2+2 = 4，
1+3 = 4，  2+3 = 5，  3+3 = 6，
1+4 = 5，  2+4 = 6，  3+4 = 10， 4+4 = 11，
1+5 = 6，  2+5 = 10，3+5 = 11， 4+5 = 12，5+5 = 13，
1+6 = 10，2+6 = 11，3+6 = 12， 4+6 = 13，5+6 = 14， 6+6 = 15，
 
乘法表
1 * 1 = 1，
1 * 2 = 2，  2*  2 = 4，
1 * 3 = 3，  2 * 3 = 6，  3 * 3 = 12，
1 * 4 = 4，  2 * 4 = 11，3 * 4 = 15， 4 * 4 = 22，
1 * 5 = 5，  2 * 5 = 13，3 * 5 = 21， 4 * 5 = 26，5 * 5 = 34，
1 * 6 = 6，  2 * 6 = 15，3 * 6 = 24， 4 * 6 = 33，5 * 6 = 42， 6 * 6 = 51，
 
23456+54356=11145     
5621- 654 =4624 

234 * 65= 22566

            234
   *         65
--------------
           1536
         2103
--------------
        22566


1、计算机中，由于受硬件的制约，数据都是有长度限制的(我们称为数据宽度）超过最多宽度的数据会被丢弃
2、4位宽表示，假如计算机只能存储4位2进制数
3、8位宽表示：假如计算机只能存储8位2进制数  2个16进制


常用的计量单位
BYTE 字节   8BIT
WORD 字   16BIT    2字节
DWORD 双字 32BIT  4字节

二进制的逻辑运算

1、逻辑运算，或（or  | ）只要有一个1就为1

        1011000101
or    1001100110
-------------------
       1011100111

2、逻辑运算，与 （and  &）两个都为1才是1

          1011000101
and    1001100110
---------------------
          1001000100         

3、逻辑运算，异或（xor  ^)不一样为1

         1011000101
xor    1001100110
-------------------- 
         0010100011

4、逻辑运算，非（not  ！）1是0， 0是1      

not    1001100110
--------------------
          0110011001 

5、逻辑运算符，左移（<<）向左移动

     0010<< 1 == 0100


CUP如何计算2+3=？ 5

  X:  0010
  Y:  0011                                 

        0010                 ——>                 0010            ——>              等于0计算结束        
xor   0011                                  &      0011                             0010<< 1 == 0100  
-------------             R:0001        --------------                        
         0001                                          0010                                
                              
                               结果
 X:  0001                 R:0101
 Y:  0010                  5 

         0001                                         0001      
xor    0100                ——>       &     0100           ———>         
--------------                            -- ------------                    0000<<1 == 0000
         0101                                         0000       


最简单的加密算法 ： xor  

   要加密的数据： 2015                   20                                    15     
                                                   0010 0000                      0001 0101        
   密钥： 54                        xor    0101 0100             xor    0101 0100
                                         -------------------          -------------------                                   
                                                   0111 0100                      0100 0001
   加密后结果                                   74                                 41
            
                                               0111 0100                     0100 0001
                                      xor    0101 0100            xor    0101 0100
                                     -------------------            ------------------- 
                                               0010 0000                     0001 0101
解密后结果：                               20                                  15



通用寄存器：

        寄存器                                  编号(二进制)        编号（十进制）
 32位    |   16位   |  8位                         
 EAX     |  AX      |  AL                      000                         0
 ECX     |  CX      |  CL                      001                         1
 EDX    |  DX      |  DL                      010                         2
 EBX     |  BX      |  BL                       011                         3
 ESP     |  SP      |  AH                      100                         4
 EBP     |  BP      |  CH                      101                         5
 ESI      |  SI       |  DH                      110                         6
 EDI     |  DI      |   BH                       111                        7


内存  

1、内存格式
 
1.每个内存单元的宽度为8 BIT ，一字节
2.[编号] 称为地址
3.地址的作用，当我们想从内存中读取数据或想向内存中写入

2、从指定内存中写入/读取数据

 语法：
            宽度     指针                                  立即数
 mov  dword   ptr  ds:[0x0012FF34] ,  0x12345678

 mov eax, dword  ptr ds:[0x0012FF34] 

dword：要读/写多少  此时是4字节   byte == 1字节   word == 2字节
ptr：Point 代表后面是一个指针（指针的意思就是里面存的不是普通的值，而是地址）
ds：段寄存器
0x0012FF34：内存编号，必须是32位的，前面0可以省略

注意：地址编号不要随便写，因为内存是有保护的，并不是所有的内存都可以直接读写（需要特别处理）
建议地址编号写成esp的值


EFLAGS寄存器

 位置   名称      标志                   //   _  表 重点 背下来 
 0         CF_      进位标志
 2         PF_      奇偶标志
 4         AF_      辅助进位标志
 6         ZF_      零标志
 7         SF_      符号标志
 8         TF       单步标志
 9         IF        中后段使用标志
10        DF       方向标志
11        OF_       溢出标志
 

1. 进位标志CF（Carry Flag) :如果运算结果的 _最高位_  产生了一个进位或借位，那么，其值为1，否则其值为0；
   注意： 先确定数据宽度  才能确定最高位  最高位进位  CF的值变为1； 反之0
 
  MOV  AL， 0xEF			MOV   AL,  0xEF
  ADD  AL,    2	  		ADD   AL， 2 

借位情况  最高位借位  CF的值才为1  

	80 - 81 
	
	   1000 0000      
	-  1000 0001
              -----------------
                    1111  1111           CF = 1
        FF = -1 
   

2.如果奇偶标志PF( Parity Flag ) ：奇偶标志PF用于反应运算结果中   _" 1 ”的个数 _ 的奇偶性。
   如果 “1 ”的个数  为偶数，则PF的值为1， 否则其值为 0 。     （此“1”的个数   表示二进制中1的个数）

   MOV  AL， 3
   ADD   AL， 3
   ADD   AL， 2

PF：

803 

0000 1000 0000 0011                     加1
0000 1000 0000 0100        PF = 0

 804 
0000 1000 0000 0100         PF = 0

814
0000 1000 0001 0100         PF = 1

总结：PF的值只看最低有效（1）字节


3.辅助进位标志AF( Auxiliary Carry Flag），
 
在发生下列情况时，辅助进位标志AF的值为1，否则其值为0，
 （1）、在字操作时，发生低字节向高字节进位或借位时；

 （2）、在字操作时，发生低4位向高4位进位或借位时，

   MOV  EAX， 0x55EEFFFF		MOV  AX,EFE		MOV  AL,  4E
   ADD   EAX,   2			ADD  AX, 2		ADD   AL,  2

4. 零标志ZF（Zero Flag）；零标志ZF用来反应运算结果是否为0。
 如果运算结果为0，则其值为1，在判断运算结果是否为0时，可使用此标志位。

  XOR  EAX， EAX     清零
 
  MOV  EAX,  2
  SUB    EAX,  2

5. 符号标志SF（Sign Flag）；符号标志SF用来反映运算结果的符号位，他与运算结果的最高位相同。

  MOV   AL， 7F
  ADD    AL， 2

6. 溢出标志OF（Overflow Flag），溢出标志用于反应有符号数加减运算所得结果是否溢出
   如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为1。

   最高位进位与溢出的区别：
 
   进位标志表示  无符号  数运算结果是否超出范围
   溢出标志表示  有符号  数运算结果是否超出范围
   溢出主要时给有运算符号使用的，再有符号的运算中，有如下规律：

   正 + 负 = 正  如果结果是负数，则说明有溢出
   负 + 负 = 负   如果结果时正数，则说明有溢出
   正 + 负       永远不会有溢出


 OF： 

加法：若同符号数相加，而结果符号与之相反，则OF = 1，否则OF = 0
加法：若不同符号相加，一定没有溢出 
减法：被减数与减数异号，而结果的符号与减数相同则 OF = 1，否则 OF= 0

计算机如何判断是否溢出

mov  al,  80
sub   al,  40

相当于

 mov  al, 80
 add   al, 0c0

     1000 0000
+   1100 0000
----------------

 符号位有进位：1
最高有效数值位向符号位产生的进位：0

1   xor  0 == 1       所以 OF = 1



Windows堆栈的特点：

1. 先进后出
2.向低地址扩展

什么是堆栈平衡：

  Windows中的堆栈，是一块普通的内存，主要用来存储临时的数据和参数等，可以把Windows中
的堆栈想象成一个公用的书箱，函数就像是使用箱子的人，函数在执行的时候，会用到这个书籍，
把一些数据存到里面，但用完的时候一定要记得把书拿走，否则会乱，也就是说，你放进去几本书，
走的时候也要拿走几本书，这个就是堆栈平衡
























