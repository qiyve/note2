封装：

	1、将函数定义在结构体内部，就是封装
	2、编译器会自动传递结构体的指针给函数
类：
	带有函数的结构体，称为类
成员函数：
	结构体里面的函数，称为成员函数
	a.函数本身不占用结构体的空间,(函数不属于结构体)
	b.调用成员函数的方法与调用结构体成员的语法是一样的  -->  结构体名称 . 函数名();

this指针的特点：
	1、你用或者不用，他就在哪里
	2、参数个数确定的时候ecx来传递
	3、参数个数不确定的时候，最后一个传递（参见不定长参数）
	4、this指针不能做++ -- 等运算，不能重新赋值
	5、this指针不占结构体的宽度

构造函数的特点：
	1、与类同名
	2、没有返回值
	3、创建对象的时候执行
	4、主要用于初始化
	5、可以有多个(最后有一个无参的),称为重载，其他函数也可以重载
	6、编译器不要求必须提供

析构函数特点：
	1、只能有一个函数，不能重载
	2、不能带任何参数
	3、不能带返回值
	4、主要用于清理工作
	5、编译器不要求必须提供
	
继承：
	继承的本质就是数据的复制
	1、继承就是数据的复制
	2、减少重复代码的编写
	3、父类又称为基类
	4、子类又称为派生类
	5、可以通过父类指针指向子类的对象
	6、一个子类可以有多个父类，即多重继承

public、private使用 ：
	1、对外提供函数或变量，发布成public的，但不能随意改动
	2、可能会变动的函数或变量，定义成private的 这样编译器会使用的时候做检查
	3、只有结构体内部的函数才可以放文件private的成员
	4、public / private可以修饰函数也可以修饰变量

总结：
	private修饰的成员与普通的成员没有区别 只是编译器会检测
	private修饰的成员只要自己的其他成员才能访问

class与struct的区别
	1、编译器默认为class中的成员为private 而struct中的成员为public
继承中:
	2、父类中的成员被继承后默认变成private属性，可以通过pulib来修改为公共属性
	3、父类中的私有成员是会被继承的
	4、只是编译器不允许直接进行访问（可以利用指针访问）

虚函数间接调用：
	1、通过对象调用时，virtual函数与普通函数都是E8 Call
	2、通过指针调用时，virtual函数是FF Call， 也就是间接 Call
	3、当类中有虚函数时，会多一个属性，4字节
	4、多出的属性是一个地址，指向一张表，里面存储了所有的虚函数地址 即虚函数表
	5、如果 同时直接继承 两个父类的虚函数时，那么会出先两个虚函数表。 第二个虚表地址为 首地址 + 4

前期绑定与动态绑定：
	绑定就是将函数调用与地址关联起来 (ps:传父类对象过去，但在编译时已经确定，属于编译期绑定或前期绑定)
	前期绑定就是编译的时候就已经确定地址
动态绑定
	1、同一个个体，体现出了不同的行为，称为多态
	2、只有virtual的函数时动态绑定
	3、动态绑定还有一个名字：多态

模板：
	模板的本质就是代码的复制

二分查找：
	1、必须是有序序列
	2、创建两个变量记录 该数组的起始 和 结束两 个下标
	3、（用起始加标 + 结束下标) / 2    =  X    如果得到值 X > 查找值 则遍历该值的左半数组，大于 则反之
	4、可以写成  x = (begin + end) /2 ;  或者  (begin + end) >> 1   右移1位 = 除2    左移1位 = 乘2    
	   位运算的效率要比 普通运算符 高；

引用类型：
	1、引用类型是C++里面的类型
	2、引用类型只能赋值一次，不能重新赋值
	3、引用只是变量的一个别名
	4、引用可以理解成为是编译器维护的一个指针，但不占用空间
	5、使用引用可以像指针那样去访问、修改对象的内容，但更加完全

友元函数：
	什么情况下需要友元函数
	1. 运算符重载的某些场合需要使用友元
	2. 两个类要共享数据的时候
	
	友元函数和类的成员函数的区别
	1. 成员函数有this指针，而友元函数没有this指针
	2. 友元函数是不能被继承的，就像父亲的朋友未必是儿子的朋友

运算符重载：
	1、运算符重载就是函数替代
	2、 .  :: ? sizeof # 不能重载

Vertor 
	1、本质就是一个数组
	2、可以动态扩充容量
	3、支持下标方式，查询性能好
	4、新增数据和删除数据较差

链表特点：
	1、数据分散存储
	2、查询性能没有Vector好
	3、新增与删除的性能好于Vector

二叉树概念(拓展)：
	满二叉树：除叶子节点外，所有节点都有两个节点，叶子节点的Left，Right 为NULL；
	完全二叉树：除最底层的叶子节点外，其余层全满，而且叶子层集中在左端，堆是一种特殊的完全二叉树(全满或差一个
		节点就全满）
	平衡二叉树：所谓平衡二叉树指的是，左右两个子树的高度的绝对值不能超过1，包括AVL树，红黑树。
	哈夫曼树：又称为最优二叉树，是一种带权路径最短的树。哈夫曼编码就是哈夫曼树的应用，可以用来进行编码压缩。
		哈夫曼树的构造见哈夫曼树的构造
	红黑树：具体见红黑树问题

	度：节点拥有的子树数目称为节点的度
	深度/高度：树中节点的最大层次数

二叉树：
	1、遍历： 先序遍历（根 左 右）
		中序遍历（左 根 右）
		后续遍历（左 左 根）
	2、高度计算：
		二叉树的深度为 其左、右子树深度的最大值加1

二叉搜索树概念：

二叉搜索树又称二叉排序树，或者是一颗空树，或者是具有以下性质的二叉树：
	
	1、若它的左子树不为空，则左子树上所有节点的值都小于根节点的值
	2、若他的右子树不为空，则右子树上所有节点的值都大于根节点的值
	3、他的左右子树也分别为二叉搜索树
	4、有很好的查询性能
	5、有很好的新增和删除的性能

搜索二叉树的操作
	
 1、搜索二叉树的查找
	若根节点不为空
	如果根节点 key == 查找key，返回true
	如果根节点 key > 查找key，在它的左子树查找
	如果根节点 key < 查找key，在它的右子树查找	 

 2、搜索二叉树的插入
	如果树为空，则直接插入
	如果树不为空，按照搜索二叉树性质查找插入位置，插入新节点
	
 3、搜索二叉树删除

	判断查找元素是否在二叉搜索树中如果在分一下几种情况
	1：如果要删除的节点只有左子树，那么就让该节点的 父节点 指向该节点的左子树，然后删除该节点
	2：如果要删除的节点只有右子树，那么就让该节点的 父节点 指向该节点的右子树，然后删除该节点
	3：要删除的节点的左右子树都存在
	
  情况3实现步骤：
	1. 用右子树中的最小的节点，与该节点的值交换
	2. 再递归删除最小节点


















































































