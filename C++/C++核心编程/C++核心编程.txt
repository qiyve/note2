C++核心编程
                    本阶段主要针对C++面向对象 编程技术做详细讲解 ，探讨C++中的核心和精髓

       1、 内存分区模型
                   c++程序在执行时，将内存大方向划分为4个区域

                               (1)、 代码区：存放函数体的二进制代码，有操作系统进行管理的
                             （2)、 全局区：存放全局变量和静态变量以及常量
                               (3)、 栈区   ： 由编译器自动分配释放，存放函数的参数值，局部变量
                             （4)、 堆区   ： 由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收
            
                内存四区意义：

                                   不同区域存放，赋予不同的生命周期，给我们更大的灵活编程
                       
        1.1      程序运行前 ： 
                                    在程序编译后，生成 exe可执行程序，为执行该程序前分为两个区域
                        
                      代码区  ： 
                                  1.   存放CPU执行的机器指令

                                   2. 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在
                                       内存中有一份代码即可。
                         
                                   3. 代码区是只读的，使其只读的原因是防止程序意外的修改了它的指令
                      全局区 ：
                                   1.  全局变量和静态变量存放在此
                                                                                                                                 （全局常量）
                                   2.  全局区还包含了常量区，字符串常量和其他常量也存放在此（const修饰的全局变量）
        1.2    程序运行后 ：                             

                                        该区域数据在程序结束后由操作系统释放
                         栈区    ： 
                                       由编译器分配释放，存放函数的参数值，局部变量等

                            注意事项 ：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放

                       堆区   ：
                                  1.  由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收
                                  2.  在c++中主要利用new在堆区开辟内存

      1.3    new操作符   ：
                                   C++中利用new操作符在堆区开辟数据
                                   
                                   队去开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 delete
 
                         语法 ： new 数据类型 

                                  利用new 创建的数据，会返回该数据对应的类型的指针

    2、引用

       2.1、引用的基本使用
       
                          作用 ：给变量起别名

                          语法 ：数组类型 &别名 = 原名

       2.2  引用的注意事项
                   
                          1. 引用必须初始化
 
                          2. 引用在初始化后，不可以改变

      2.3 引用做函数参数
                 
                         作用 ：函数传参时，可以利用引用的技术让形参修饰实参

                         优点 ：可以简化指针修改实参   

      2.4 引用做函数返回值

                          作用：引用是可以作为函数的返回值存在的
  
                          注意 :  不要返回局部变量引用

                          用法： 函数调用作为左值

      2.5引用的本质

                         本质： 引用的本质在C++内部实现是一个指针常量

                         结论： C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针
                                    操作编译器都帮我们作了。               

      2.6常量引用 

                         作用：常量引用主要用来修饰形参，防止防止操作

                                   在函数形参列表中，可以加const修饰形参，防止误操作
                                     
3、函数提高  
               
           3.1函数的默认参数

                                    在c++中，函数的形参列表中的参数是可以有默认值的
 
                      语法：  返回值  函数名   (参数=默认值) { }

           3.2函数占位参数

                                    c++中函数的形参列表里有展位参数，用来做占位，调用函数时必须填补该位置

                      语法 ：  返回值类型   函数名  （数据类型）{ }

         3.3 函数重载
         
                3.3.1 函数重载概念： 

                       作用 ：  函数名可以相同，提高复用性

                  函数重载满足条件： 

                                (1)  同一个作用域下                         
                                (2)  函数名相同
                              （3） 函数参数类型不同或者个数不同 或者 顺序不同

                      注意：
                                  函数的返回值不可以作为函数重载的条件

               3.3.2函数重载注意事项
 
                                （1） 引用作为重载体条件

                                 （2） 函数重载碰到函数默认参数   
                

4、类和对象 
                                c++面向对象的三大特性为： 封装 、继承、多态
            
                                c++认为万事万物皆为对象，对象有属性和行为

                   例如 :   人可以作为对象，属性有姓名、年龄、身高、体重....行为有走、跑、跳、吃饭、唱歌......

                               车也可以作为对象，属性有轮胎、方向盘、车灯...行为有载人、放音乐、放空调

                               具有相同性质的对象，我们可以抽象称为类，人属于人类，车类属于车类

      4.1 封装 ：

                               封装是c++面向对象三大特性之一
  
         4.1.1封装意义
  
                         （1）将属性和行为作为一个整体，表现生活中的事务
 
                           (2)  将属性和行为加以权限控制

           封装意义一

                               在设计类的时候，属性和行为写在一起，表现事务

                       语法 :  class  类名 {  访问权限 ：属性 / 行为} ；

          封装意义二

                       类在设计时，可以把属性和行为放在不同的权限下，加以控制

             访问权限有三种

                        1、  public         公共权限  ： 成员 类内可以访问  类外也可以访问

                        2、  protected    保护权限  ：成员 类内可以访问  类外不可以访问   儿子也可以访问父亲中的保护内容（继承中）
 
                        3、  private        私有权限   ：成员 类内可以访问  类外不可以访问   儿子不可以访问父亲的私有内容（继承中）

     4.1.2 struct和class区别

            在C++中struct和class唯一区别就在于 默认的访问权限不同 
 
                    区别 ：

                              1. struct 默认权限为公共
 
                              2++. class  默认权限为私有

     4.1.3 成员属性设置为私有

                   优点1：将所有成员属性设置为私有，可以自己控制读写权限

                   优点2：对于写权限，我们可以检测数据的有效性

   4.2  对象的初始化和清理

                    1.在生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全

                    2.C++中的面向对象来源于生活，每个对象也都会有初始值以及 对象销毁前的数据清理的设置

      4.2.1构造函数和析构函数
 
           对象的初始化和清理也是两个非常重要的安全问题

                    一个对象或者变量没有初始状态，对其使用后果是未知

                   同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题

           C++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。
            对象的初始化和清理工作是编译器强制我们要做的事情，因此如果  （ 我们不提供构造和析构，编译器会提供编译器
           提供的构造函数和析构函数是空实现 ）。              

                  1.构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用

                  2. 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作                    
                
          构造函数 语法： 类名（）{ }   

                  1.构造函数，没有返回值也不写void

                  2.函数名称与类名相同
                  
                  3.构造函数可以有参数，因此可以发生重载
               
                 4. 程序在调用对象时候会自动调用构造，无需手动调用，而且只会只会调用一次

         析构函数 语法 : ~类名（）{ }

                 1.析构函数，没有返回值也不写void 

                 2.函数名称与类名相同，在名称前加上符号 ~ 
   
                 3.析构函数不可以有参数值，因此不可以发生重载

                 4.程序在对象销毁前会自动调用析构，无需手动调用，而且只会调用一次

     4.2.2 构造函数的分类及调用

             两种分类方式：
 
                           按参数分为： 有参构造和无参构造

                           按类型分为： 普通构造和拷贝构造

            三种调用方法：

                         括号法

                         显示法

                         隐式转换发
  
    4.2.3拷贝构造函数调用时机
                     
                  c++中拷贝构造函数调用时机通常有三种情况
 
                       1.使用一个已经创建完毕的对象来初始化一个新对象

                       2.值传递的方式给函数参数传值

                       3.以值方式返回局部对象

   4.2.4构造函数调用规则

            默认情况下，C++编译器至少给一个类添加3个函数

                        1.默认构造函数（无参 函数体为空）

                         2.默认析构函数（无参 函数体为空）

                         3.默认拷贝构造函数，堆属性进行值拷贝

             构造函数调用规则如下

                         1.如果用户定义有参构造函数，C++不再提供默认无参构造，但是会提供默认拷贝构造

                         2.如果用户定义拷贝构造函数，c++不会再提供其他构造层次

   4.2.5深拷贝与浅拷贝

               深浅拷贝是面试经典问题，也是常见的一个坑

                        浅拷贝： 简单的复制拷贝操作

                        深拷贝： 在堆区重新申请空间，进行拷贝操作

                 总结： 如果属性有在堆区开辟的，一定要自己提供拷贝函数，防止浅拷贝带来的问题

   4.2.6初始化列表

                 作用 ：C++提供了初始化列表，用来初始化属性

                 语法 ：  构造函数（）：属性1（值1），属性2（值20）....{ } 

   4.2.7类对象作为类成员

             c++中的成员可以是另一个类的对象，我们称该成员为对象成员

   4.2.8静态成员 

             静态成员就是在成员变量和成员函数前加上关键字 static ，称为静态成员

           静态成员分为：

                     静态成员变量
            
                           1.所有对象共享同一份数据

                           2.在编译阶段分配内存

                           3.类内声明，类外初始化

                      静态成员函数

                           1.所有对象共享同一个函数

                           2.静态成员函数只能访问静态成员变量

 4.3C++对象模型和this指针

        4.3.1成员变量和成员函数分开存储

             在c++中，类内的成员变量和成员函数分开存储

             只有非静态成员变量才属于类的对象上

       4.3.2 this指针概念

              通过4.3.1我们知道在C++中成员变量和成员函数是分开储存的
              每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象，会共用一块代码
              那么问题是：这一块代码是如何区分那个对象调用自己的呢？

              C++通过提供特殊的对象指针，this指针，解决上述问题，{this指针指向被调用的成员函数所属的对象}

              this指针是隐含每一个非静态成员函数内的一种指针

              this指针不需要定义，直接使用即可

      this指针的用途：

             1.当形参和成员变量同名时，可用this指针来区分

             2.在类的非静态成员函数中返回对象本身，可使用return *this  

   4.3.3空指针访问成员函数

             c++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针

             如果用到this指针，需要加以判断保证代码的健壮性

  4.3.4const修饰成员函数

            常函数

                  1.成员函数后加const后我们称为这个函数为常函数

                  2.常函数不可以修改成员属性

                  3.成员属性声明时加关键字mutable后，在常函数中依然可以修改

           常对象
            
                  1.声明对象前加const称该对象为常对象

                  2.常对象只能调用常函数

4.4、友元
  
                在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术
   
                友元的目的就是让一个函数或者类访问另一个类中私有成员
 
                友元的关键字 friend
   
            友元的三种实现：

                   1.全局函数做友元

                   2.类做友元

                   3.成员函数做友元

4.5、运算符重载      

            运算符重载：operator

           运算符重载概念：对已有的运算符重新定义，赋予其另一种功能，以适应不同的数据类型

        4.5.1加号运算符重载

                   作用：实现两个自定义数据类型相加的运算

        4.5.2左移运算符重载

                   作用：可以输出自定义数据类型

        4.5.3递增运算符重载

                   作用：通过重载递增运算符，实现自己的整形数据
                   
       4.5.4 赋值运算符重载

             c++编译器至少给一个类添加4个函数

                    1.默认构造函数（无参 函数体为空）

                    2.默认析构函数（无参 函数体为空）
                    
                    3.默认拷贝构造函数，对属性进行值拷贝

                    4.赋值运算符operator=，对属性进行值拷贝

           如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题                    
             
    4.5.5 关系运算符

              重载关系运算符，可以让两个自定义数据类型进行对比操作

    4.5.6函数调用运算符重载
 
             1.函数调用运算符（）也可以重载

             2.由于重载后使用的方式非常像函数的调用，因此称为仿函数

             3.由于仿函数没有固定写法，非常灵活

4.6 继承

              继承是面向对象的三大特性之一
  
   4.6.1继承的基本语法  

                  优点 ：  减少重复代码
    
                class A :public  B;
                A类称为子类或者派生类
                B类称为父类或者基类
                            
         派生类中的成员，包含两大部分

                  一类是从基类继承过来的，一类是自己添加的成员

                  从基类继承过来的表现其 共性，而新增的成员体现了其 个性
        
   4.6.2 继承方式
  
               继承的语法： class 子类 ：继承方式  父类

          继承方式一共有三种：

                 1.公共继承

                 2.保护继承

                 3.私有继承

  4.6.3 继承的对象模型
 
              父类中所有非静态成员属性都会被子类继承下去

              父类中私有成员属性 是被编译器给隐藏了 因此是访问不到的 但是确实被继承下去了

  4.6.4 继承中构造和析构顺序

              子类继承父类后，当创建子类对象，也会调用父类中的构造函数

              继承中构造和析构的顺序

              先构造父亲；在构造儿子，析构的顺序与构造顺序相反

  4.6.5 继承同名成员处理方式

              1.访问子类同名成员  直接访问即可

              2.访问父类同名成员  需要加作用域

   4.6.6继承同名静态成员处理方式

          静态成员和非静态成员出现同名，处理方式一致

             1.访问子类同名成员，直接访问即可

             2.访问父类同名成员，需要加作用域

   4.6.7多继承语法
     
           C++允许一个类继承多个类

            语法： class 子类 ：继承方式  父类，继承方式  父类2 ...

           多继承可能会引发父类中有同名成员出现，需要加作用域区分

           C++实际开发中不建议用多继承 

  4.6.8 菱形继承

          菱形继承概念：

                  两个派生类继承同一个基类

                  又有某个类同时继承这两个派生类

                  这种继承被称为菱形继承或者钻石继承

           总结：

              1. 菱形继承带来的问题主要是子类继承两份相同的数据，导致资源浪费以及毫无意义

              2. 利用虚继承可以解决菱形继承问题      

4.7多态 

    4.7.1 多态的基本概念

              多态是C++面向对象三大特性之一

              多态分为两类：
               
                    1.静态多态：函数重载和运算符重载属于静态多态，复用函数名

                    2.动态多态：派生类和虚函数实现运行多态

              静态多态和动态多态区别：

                    1.静态多态的函数地址早绑定 - 编译阶段确定函数地址

                    2.动态多态的函数地址晚绑定 - 运行阶段确定函数地址             

   4.7.2多态案例——计算器

             多态优点：1.代码组织结构清晰   2.  可读性强     3. 利于前期和后期的扩展以及维护

   4.7.3 纯虚函数和抽象类

              再多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容

               因此可以将虚函数改为纯虚函数
 
               纯虚函数语法 virtual   返回值类型  函数名 （参数列表）=0；

               当类中有了纯虚函数，这个也称为抽象类

            抽象类特点 

                       1.  无法实例化对象

                        2. 子类必须重写抽象类中的纯虚函数，否则也属于抽象类

   4.7.5 虚析构和纯虚析构

              多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码
 
              解决方式 ： 将父类中的析构函数改为 虚析构 或者 纯虚析构

              虚析构和纯虚析构共性：

                        1.可以解决父类指针释放子类对象

                        2. 都需要有具体的函数实现

                虚析构和纯虚析构区别：
 
                        1.如果是纯虚析构，该类属于抽象类，无法实例化对象

                 虚析构语法：
            
                      virtual ~ 类名（）{ }；

               纯虚析构语法 ：

                      virtual ~ 类名 （） = 0；
                       类名 :: ~ 类名（）{ }
        
5、文件操作

             程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放

             通过文件可以将数据持久化

              C++中对文件操作需要包含头文件<fstream>

          文件类型分为两种 ：

                    1、文本文件  - 文件以文本的ASCLL码形式存储在计算机内

                    2、二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们

          操作文件的三大类
           
                ofstream: 写操作
 
                 ifstream: 读操作
 
                 fstream:   读写操作

    5.1 文本文件 
 
           5.1.1 写文件

                  写文件步骤 ：

                    1. 包含头文件   #include<fstream>

                    2. 创建流对象   ofstream ofs;

                    3. 打开文件       ofs.open("文件路径“,  打开方式)
 
                    4. 写数据           ofs<<"写入的数据“;

                    5. 关闭文件        ofs.close()；

            文件打开方式：

                   ios :: in          为读文件而打开文件

                   ios :: out        为写文件而打开文件

                   ios :: ate        初始位置 ：文件尾

                   ios :: app       追加方式写文件

                   ios :: trunc     文件存在先删除，在创建

                   ios :: binary     二进制方式

          注意： 文件打开方式可以配合使用 ，利用 | 操作符

          例如： 用二进制方式写文件 ios :: binary  |  ios :: out 
                            
     5.1.2 读文件

                  读文件步骤 ：

                    1. 包含头文件   #include<fstream>

                    2. 创建流对象   ifstream ifs;

                    3. 打开文件       ifs.open("文件路径“,  打开方式)  判断文件是否打开成功
 
                    4. 读数据          四种方式读取

                    5. 关闭文件       ifs.close()；

   5.2 二进制文件

              以二进制的方式对文件进行读写操作

              打开方式要指定为  ios :: binary

      5.2.1 写文件

              二进制方式写文件主要利用流对象调用成员函数 write

              函数原型 ： ofstream& write (const char * buffer, int len);

              参数解释： 字符指针buffer指向内存中一段存储空间，len 是读写的字节数 

     5.2.2 读文件

              二进制方式读文件主要利用流对象调用成员函数 read
 
              函数原型： istream & read (char * buffer,int len)；

              参数解释： 字符指针buffer 指向内存中一段存储空间。len 是读写的字节数









