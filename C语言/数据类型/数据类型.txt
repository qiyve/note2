2、数据类型

  2.1 常量与数据

    2.1.1关键字

     数据类型关键字（12）

        char(字符)  short(短)  int(整)  long(长)  float(单精)  double(双精)  unsigned(无符号否定)
        signed(有符号)  struct(定义结构体)  union(联合体) enum(枚举)  void(空类型)

      控制语句关键字（12）

        if else(判断)   switch case default(分支)   for  do while(循环)  break(分支循环退出) 
        continue(结束本次执行下次)  gouto(无条件跳转)  return(函数中结束本函数，主函数结束程序)

      存储类关键字（5）

        auto(局部变量)   extern(声明)  register   static(静态)  const

      其他关键字（3）

       sizeof(字节)  typedef()   volatile()

    2.1.2 数据类型

      数据类型的作用：编译器预算对象(变量)分配的内存空间大小

    2.1.3 常量 

       在程序运行过程中，其值不能被改变的量

       常量一般出现在表达式或赋值语句中

   常量定义方式：
 
       1. const 数据类型  常量名 = 值 （不安全）
       2. #define 常量名 值

    2.1.4 变量

      在程序运行过程中，其值可以改变

      变量在使用前必须先定义，定义变量前必须有相应的数据类型
  
      定义格式：

        数据类型  变量 = 值

  
  进 制：

十进制 ：以正常数字1-9开头 如123
八进制 ：以数字0开头，如0123
十六进制：以0x开头，如0x123
二进制 ：C语言不能直接书写二进制数
 
scanf 安全问题解决：
#define  _CRT_SECURE_NO_WARNINGS
#pragma warning (disable:4996)

ASCll 对照表

0 ：48
A ：65
a ：97

十进制的小数转成二进制： 小数部分和2相乘，取整数，不足1取0，每次相乘都是小数
部分，顺序看取整后的数就是转化后的结果

十进制转二进制：

          用十进制数除以2，分别取余数和商数，
          商数为0的时候，将余数倒着数就是转化后的结果

1.乘的时候只乘小数部分
2.小数点后有几位，就乘几次
3.取到后前面加上 0. 


二进制存储术语：

bit(比特)           ：一个二进制代表一位，一个位只能表示0或1两种状态，
                           数据传输是习惯以”位“(bit)为单位

Byte(字节)        ：一个字节为8个二进制，称为8位，计算器中存储的最小单位是字节。
                           数据习惯以”字节“(Byte)为单位

WORD(双字节)：两个字节 16位
DWORD          ：两个WORD，4个字节，32位

1b               :  1bit ，1位
1B                : 1Byte，1字节，8位
1k,1K           :  1024
1M(1兆)       ：1024k,  1024*1024
1G               :  1024M
1T                :  1024G
1Kb(千位)    ：1024bit，1024位
1KB(千字节) ：1024Byte，1024字节
1Mb(兆位)   ：1024Kb=1024*1024bit
1MB(兆字节):   1024KB=1024*1024Byte


计算器内存数据存储方式

源码：
  - 最高为左为符号位，0表示正，1表示负
  - 其他数值部分就是数值本身绝对值的二进制数
  - 负数的原码就是在其绝对值的基础上，最高位变为1

反码：

  - 对于正数，反码与源码相同
  - 对于负数，符号位不变，其他部分取反(1变0，0变1)

补码：
    
   - 对于正数，原码、反码、补码相同
   - 对于负数，其补码为他的反码加1
   - 补码符号位不动，其他位求反，最后整个数加1，得到原码

char ch = 10;
源码：0000 1010
反码：0000 1010
补码：0000 1010
char ch1 = -10;
源码：1000 1010
反码：1111  0101
补码：1111  0110

 在计算机系统中一律用补码存储 原因：

 - 统一了零的编码
 - 将符号位和其他位统一处理
 - 将减法运算变为加法运算
 - 两个用补码表示的数相加时，如果用最高位(符号位)有进制，则进位被舍弃

40 - 30 
源码：0010 1000
反码：0010 1000
补码：0010 1000

源码：1001 1110
反码：1110 0001
源码：1110 0010

补码：0010 1000
源码：1110 0010
010100001
源码：1 0000 1010
反码：0000 1010
源码：0000 1010
   
50 - 35

源：0011 0010
反：0011 0010
补：0011 0010

源：1010 0011
反：1101 1100
补：1101 1101

补：0011 0010
补：1101 1101
1 0000 1111
补：0000 1111
反：0000 1111
源：0000 1111

有符号字符型取值范围： -2^7 ~ 2^7-1  -128 ~ 127
8bit数据区间为： -2^7 ~ 2^7-1
原码：0111 1111  2^7-1 = 127
最小值：
原码：1111 1111   -127
反码：1000 0000
补码：1000 0001 = -127

数据存储时将 -0对应的区间值设为最小值 -2^7 

signed int 32bit  -2^31 ~ 2^31-1    -2147483648 ~ 2147483648

无符号 
数据存储在计算机中不存在符号位
unsigned char  
源码：1111 1111   2^8-1  最大
源码：0000 0000   0
unsigned char    0~ 255

unsigned int   0~4294967295
1111 1111 1111 1111 1111 1111 1111 1111   2^32-1
0000 0000 0000 0000 0000 0000 0000 0000   0 


类型限定符

extern   ：声明一个变量，extern声明的变量没有创建存储空间
const    ：定义一个常量，常量的值不能修改
Volatile ：防止编译器优化代码
register ：定义寄存器变量提高效率，register是建议型指令，
                 CPU有空闲寄存器就生效，没有 反之（不建议使用）




  
